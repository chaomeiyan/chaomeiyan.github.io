<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>置顶</title>
      <link href="/9999/02/09/%E7%BD%AE%E9%A1%B6/"/>
      <url>/9999/02/09/%E7%BD%AE%E9%A1%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="博客会记录一些课程笔记和课程实验报告，还有一些技术类文章和生活类文章，欢迎参观！"><a href="#博客会记录一些课程笔记和课程实验报告，还有一些技术类文章和生活类文章，欢迎参观！" class="headerlink" title="博客会记录一些课程笔记和课程实验报告，还有一些技术类文章和生活类文章，欢迎参观！"></a>博客会记录一些课程笔记和课程实验报告，还有一些技术类文章和生活类文章，欢迎参观！</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中yield的用法详解——最简单，最清晰的解释</title>
      <link href="/2020/02/14/python%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%8C%E6%9C%80%E6%B8%85%E6%99%B0%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2020/02/14/python%E4%B8%ADyield%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%8C%E6%9C%80%E6%B8%85%E6%99%B0%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>首先我要吐槽一下，看程序的过程中遇见了yield这个关键字，然后百度的时候，发现没有一个能简单的让我懂的，讲起来真TM的都是头头是道，什么参数，什么传递的，还口口声声说自己的教程是最简单的，最浅显易懂的，我就想问没有有考虑过读者的感受。</p><p>接下来是正题：</p><p>首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(next(g))</span><br></pre></td></tr></table></figure><p>就这么简单的几行代码就让你明白什么是yield，代码的输出这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line"></span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>我直接解释代码运行顺序，相当于代码单步调试：</p><p>1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p><p>2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环</p><p>3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，</p><p>4.程序执行print(“<em>“</em>20)，输出20个*</p><p>5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p><p>6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.</p><p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">g = foo()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p>再看一个这个生成器的send函数的例子，这个例子就把上面那个例子的最后一行换掉了，输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">starting...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line"></span><br><span class="line">res: <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>先大致说一下send函数的概念：此时你应该注意到上面那个的紫色的字，还有上面那个res的值为什么是None，这个变成了7，到底为什么，这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。</p><p>5.程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量</p><p>6.由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环</p><p>7.程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。</p><p>这就结束了，说一下，<strong>为什么用这个生成器</strong>，是因为如果用List的话，会占用更大的空间，比如说取0,1,2,3,4,5,6…………1000</p><p>你可能会这样：</p><p>for n in range(1000):<br>    a=n<br>这个时候range(1000)就默认生成一个含有1000个数的list了，所以很占内存。</p><p>这个时候你可以用刚才的yield组合成生成器进行实现，也可以用xrange(1000)这个生成器实现</p><p>yield组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">"starting..."</span>)</span><br><span class="line">    <span class="keyword">while</span> num&lt;<span class="number">10</span>:</span><br><span class="line">        num=num+<span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> foo(<span class="number">0</span>):</span><br><span class="line">    print(n)</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">starting...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p> xrange(1000):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">    a=n</span><br></pre></td></tr></table></figure><p> 其中要注意的是python3时已经没有xrange()了，在python3中，range()就是xrange()了，你可以在python3中查看range()的类型，它已经是个&lt;class ‘range’&gt;了，而不是一个list了，毕竟这个是需要优化的。 </p><p>————————————————<br>版权声明：本文为CSDN博主「冯爽朗」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构和算法</title>
      <link href="/2020/02/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-解压序列赋值给多个变量"><a href="#1-解压序列赋值给多个变量" class="headerlink" title="1.解压序列赋值给多个变量"></a>1.解压序列赋值给多个变量</h3><p>直接用 = 就可以解压赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">x,y = a</span><br></pre></td></tr></table></figure><p>实际上，这种解压赋值可以用在任何可迭代对象上面，而不仅仅是<strong>列表</strong>或者<strong>元组</strong>。 包括<strong>字符串</strong>，<strong>文件对象</strong>，<strong>迭代器</strong>和<strong>生成器。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello'</span></span><br><span class="line">a,b,c,d,e = s</span><br></pre></td></tr></table></figure><p>当我们只想解压一部分时没有特殊的语法，需要使用任意变量名去占位，然后丢弃不需要的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="string">'ACE'</span>, <span class="number">50</span>, <span class="number">91.1</span>, (<span class="number">2020</span>, <span class="number">2</span>, <span class="number">14</span>)]</span><br><span class="line">_, shares, price, _ = data</span><br><span class="line"><span class="comment"># 其中_就是不错的占位符 因为平时很少用它来命名变量</span></span><br></pre></td></tr></table></figure><h3 id="2-解压可迭代对象赋值给多个变量"><a href="#2-解压可迭代对象赋值给多个变量" class="headerlink" title="2.解压可迭代对象赋值给多个变量"></a>2.解压可迭代对象赋值给多个变量</h3><p>当可迭代对象的元素个数比较多的时候，怎么才能从这个对象中解压出N个元素出来呢？</p><p>Python 的星号表达式可以用来解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(grades)</span>:</span></span><br><span class="line">first, *middle, last = grades</span><br><span class="line">    <span class="keyword">return</span> avg(middle)</span><br><span class="line"><span class="comment"># 注意 不管这个可迭代对象是什么，使用*取出的一定是列表</span></span><br></pre></td></tr></table></figure><p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值。</p><p><strong>值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。</strong> 比如，下面是一个带有标签的元组序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">records = [</span><br><span class="line">    (<span class="string">'foo'</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">'bar'</span>, <span class="string">'hello'</span>),</span><br><span class="line">    (<span class="string">'foo'</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_foo</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    print(<span class="string">'foo'</span>,x,y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_bar</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tag, *args <span class="keyword">in</span> records:</span><br><span class="line">    <span class="keyword">if</span> tag == <span class="string">'foo'</span>:</span><br><span class="line">do_foo(*args)</span><br><span class="line">    <span class="keyword">if</span> tag == <span class="string">'bar'</span>:</span><br><span class="line">        do_bar(*args)</span><br></pre></td></tr></table></figure><p><strong>星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line = <span class="string">'nobody:*:-2:-2:UnprivilegedUser:/var/empty:/usr/bin/false'</span></span><br><span class="line">uname, *fields, homedir, sh = line.split(<span class="string">':'</span>)</span><br><span class="line"><span class="comment"># split()方法的作用就是以：为界分出多个元素</span></span><br></pre></td></tr></table></figure><p><strong>有时候，你想解压一些元素后丢弃它们</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">record = (<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">123.45</span>, (<span class="number">12</span>, <span class="number">18</span>, <span class="number">2012</span>))</span><br><span class="line">name, *_, (*_, year) = record</span><br></pre></td></tr></table></figure><p><strong>在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。</strong>比如，如果你有一个列表， 你可以很容易的将它分割成前后两部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">head, *tail = items</span><br><span class="line"><span class="comment"># 类似切片效果</span></span><br></pre></td></tr></table></figure><h3 id="3-保留最后N个元素"><a href="#3-保留最后N个元素" class="headerlink" title="3.保留最后N个元素"></a>3.保留最后N个元素</h3><p>保留有限历史记录正是 <code>collections.deque</code> 大显身手的时候。比如，下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(lines, pattern, history=<span class="number">5</span>)</span>:</span></span><br><span class="line">previous_lines = deque(maxlen=history)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">yield</span> line, previous_lines</span><br><span class="line">        previous_lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example use on a file</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">r'./xxx.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line, prevlines <span class="keyword">in</span> search(f,<span class="string">'ss'</span>):</span><br><span class="line"><span class="keyword">for</span> pline <span class="keyword">in</span> prevlines:</span><br><span class="line">                print(pline, end=<span class="string">''</span>)</span><br><span class="line">                print(<span class="string">'-'</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>我们在写<strong>查询元素</strong>的代码时，通常会使用包含 <code>yield</code> 表达式的<strong>生成器函数</strong>，也就是我们上面示例代码中的那样。 这样可以将搜索过程代码和使用搜索结果代码解耦。</p><p>更一般的， <code>deque</code> 类可以被用在任何你<strong>只需要一个简单队列数据结构的场合</strong>。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = deque()</span><br><span class="line">q.append(args)</span><br><span class="line">q.pop()</span><br></pre></td></tr></table></figure><h3 id="4-查找最大或最小的N个元素"><a href="#4-查找最大或最小的N个元素" class="headerlink" title="4.查找最大或最小的N个元素"></a>4.查找最大或最小的N个元素</h3><p>怎样从一个集合中获得最大或者最小的 N 个元素列表？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown学习笔记</title>
      <link href="/2020/02/13/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/13/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown段落格式"><a href="#Markdown段落格式" class="headerlink" title="Markdown段落格式"></a>Markdown段落格式</h3><p>显示标题： #</p><p>显示字体： *  **  *** 斜体 粗体 粗斜体</p><p>分隔线：***</p><hr><p>删除线： <del>~ ~</del>    <del>示意</del></p><p>下划线： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure><p><u>示例</u></p><p>脚注： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^要注明的文本]</span><br></pre></td></tr></table></figure><p>哈哈哈[^要注明的文本]</p><h3 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 无序列表</span><br><span class="line">2. 有序列表</span><br></pre></td></tr></table></figure><ol><li>无序列表</li><li>有序列表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li></ul><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. text</span><br><span class="line">- 第一个元素</span><br></pre></td></tr></table></figure><ol><li>text<ul><li>第一个元素</li></ul></li></ol><h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块引用</span><br><span class="line"></span><br><span class="line">&gt; 区块嵌套</span><br><span class="line">&gt;&gt; 第二层</span><br><span class="line">&gt;&gt;&gt; 第三层</span><br></pre></td></tr></table></figure><blockquote><p>区块引用</p></blockquote><blockquote><p>示例</p><p>二行</p></blockquote><blockquote><p>区块嵌套</p><blockquote><p>第二层</p><blockquote><p>第三层</p></blockquote></blockquote></blockquote><h4 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; + 第一项</span><br><span class="line">&gt; + 第二项</span><br><span class="line">&gt; + 第三项</span><br></pre></td></tr></table></figure><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h4 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">    &gt; 菜鸟教程</span><br><span class="line">    &gt; 学的不仅是技术更是梦想</span><br><span class="line">* 第二项</span><br></pre></td></tr></table></figure><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h3 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h3><h4 id="函数或片段代码"><a href="#函数或片段代码" class="headerlink" title="函数或片段代码"></a>函数或片段代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;printf()&#96; 函数   使用 &#96;包围</span><br></pre></td></tr></table></figure><p><code>printf()</code> 函数</p><p><code>cout</code></p><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用&#96;&#96;&#96;来包围一段代码</span><br></pre></td></tr></table></figure><h3 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p><a href="www.baidu.com">链接名称</a></p><p>&lt;<a href="http://www.baidu,com&gt;" target="_blank" rel="noopener">www.baidu,com&gt;</a></p><h4 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">链接也可以用变量来代替，文档末尾附带变量地址：</span><br><span class="line">这个链接用 1 作为网址变量 [Google][1]</span><br><span class="line">这个链接用 Maxwell 作为网址变量 [Maxwell][maxwell]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;</span><br><span class="line">  [maxwell]: http:&#x2F;&#x2F;www.chaomeiyan.github.io&#x2F;</span><br></pre></td></tr></table></figure><h3 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br><span class="line"></span><br><span class="line">你也可以直接把图片拖进编辑器</span><br></pre></td></tr></table></figure><h3 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h3><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>我们可以设置表格的对齐方式：</strong></p><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐。</li><li><strong>:-</strong> 设置内容和标题栏居左对齐。</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h3 id="Markdown高级技巧"><a href="#Markdown高级技巧" class="headerlink" title="Markdown高级技巧"></a>Markdown高级技巧</h3><h4 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h4><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code></code>等 ，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑</span><br></pre></td></tr></table></figure><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**文本加粗** </span><br><span class="line">\*\* 正常显示星号 \*\*</span><br></pre></td></tr></table></figure><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 &#x3D;  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$</p><p>$$</p><h3 id="Markdown画流程图"><a href="#Markdown画流程图" class="headerlink" title="Markdown画流程图"></a>Markdown画流程图</h3><p><strong>1、横向流程图源码格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><p><strong>2、竖向流程图源码格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><p><strong>3、标准流程图源码格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><p>4、标准流程图源码格式（横向）：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p><strong>5、UML时序图源码样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;sequence</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;sequence</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><p><strong>6、UML时序图源码复杂样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;sequence</span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;sequence</span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><p><strong>7、UML标准时序图样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><p><strong>8、甘特图样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">​&#96;&#96;&#96;mermaid</span><br><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;mermaid</span><br><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归方法论</title>
      <link href="/2020/02/12/%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>/2020/02/12/%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>专注力与执行力是人与人之间产生差别的主要原因</title>
      <link href="/2020/02/11/%E4%B8%93%E6%B3%A8%E5%8A%9B%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%8A%9B%E6%98%AF%E4%BA%BA%E4%B8%8E%E4%BA%BA%E4%B9%8B%E9%97%B4%E4%BA%A7%E7%94%9F%E5%B7%AE%E5%88%AB%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0/"/>
      <url>/2020/02/11/%E4%B8%93%E6%B3%A8%E5%8A%9B%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%8A%9B%E6%98%AF%E4%BA%BA%E4%B8%8E%E4%BA%BA%E4%B9%8B%E9%97%B4%E4%BA%A7%E7%94%9F%E5%B7%AE%E5%88%AB%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大部分人的智力水平相差不大，那为什么到学期末的成绩差异会那么大呢？答案可能是在学期开始时不同的人先前的知识累计和能力不同，但如果是知识累计和能力相差不大的两个人，经过一个学期上课后差异很大的主要原因大概就是专注力与执行力，所谓的提升学习效率，听课效率等等归根结底都是提升专注力，如果一个人做事情足够专注，不三心二意，那他的各种表面的能力比如学习效率，听课效率，写作业效率，认真的态度都会随之而来。</span><br><span class="line">回想我考差的几科，有好几个原因导致考差，一是上课不是特别专心，有时候会看手机，有时候是因为上课走神了一会就直接听不懂导致不想听，然后课后又因为作业太多而无法弥补。二是复习的时候也不专注，总是复习一小时手机一小时，这样的复习效率直接导致期末出大问题。三是对自己的水平预估有偏差，以为自己会了但其实一考才发现其实没有掌握，这和平时总想省心省力作业不认真做，书不认真看有很大关系。平时的省心省力到期末就是爆炸。</span><br><span class="line">那解决办法有哪些呢？一是要培养自己专注的能力，二是一定要预习 以保证自己能跟上老师讲课从而不会在课下花费太多时间而得不到多少提升；三是要多刷题，那么刷题也是很考验专注力和执行力的，保质保量得刷，去多总结。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么如何提高专注能力呢？这里引用知乎上一个回答：</span><br></pre></td></tr></table></figure><p>所有学习和工作效率低的人，都有一个困惑：为什么一到要做事的时候，就会感觉全世界的风吹草动都是诱惑。</p><p>当你无法集中注意力的时候，绝大多数的勤奋都是在耗费时间，成效低下而又疲惫不堪。</p><h5 id="勤奋能决定的只是下限，真正决定人与人上限差距的，是你能否长时间将注意力集中到你正在做的事情上，全神贯注。"><a href="#勤奋能决定的只是下限，真正决定人与人上限差距的，是你能否长时间将注意力集中到你正在做的事情上，全神贯注。" class="headerlink" title="勤奋能决定的只是下限，真正决定人与人上限差距的，是你能否长时间将注意力集中到你正在做的事情上，全神贯注。"></a>勤奋能决定的只是下限，真正决定人与人上限差距的，是你能否长时间将注意力集中到你正在做的事情上，全神贯注。</h5><p>而这才是那些优秀的人身上真正拥有的特质。</p><p>他们在集中注意力学习和工作的时候，几乎可以忽略全世界，保持全身心投入、高度集中注意力。</p><p>更可怕的是，只要需要，他们往往可以一天十多个小时持续这样，经年累月、从不懈怠。</p><p>这才是隐藏在勤奋表象背后的真正特质，一种更本元的能力：<strong>专注</strong>。</p><p>专注于明确的目标，并排除干扰，这是在任何领域取得成功的关键。——威斯康星大学心理中心戴维森</p><p>十个小时的低效勤奋，也比不上一个小时的专注。</p><p>但很多人没有意识到的是，相对于勤奋之类的东西，专注更像是一种天赋，一种自发行为。</p><p>同样的家庭环境，同样的父母，两个孩子一起学习，也可能一个专心致志，一个三心二意。</p><p>我前面提到的那些清北学霸们，则几乎从小学起就总是比同龄人注意力更集中，更能够抗拒外在诱惑，保持高效率学习的时间更长。</p><p>现代的神经科学研究发现，这种能忽略干扰和抑制冲动的注意力系统，一般在小孩儿3岁时开始发展，8岁时达致成熟。</p><p>这意味着，绝大多数人的专注能力在很小的时候就已经被决定了，而有些人（大约10%）甚至天生患有注意力缺陷障碍。</p><p>他们甚至连一两个小时的专注都做不到。</p><p>后来我看心理学才知道，原来专注包括了“<strong>自下而上</strong>”和“<strong>自上而下</strong>”两套神经系统，分别对应着“<strong>本能驱动</strong>”和“<strong>动机驱动</strong>”。</p><p>自下而上，比如你跑步、打游戏的时候，不需要做什么也能集中注意力，也不用多努力，这是本能和天赋的领域。</p><p>而自上而下，就像考试前临时抱佛脚，需要克服内心的懈怠、克服外在的诱惑，时刻提醒自己。如果没有极强的动机，是很难做到的。</p><p>说实话，大家都到这个年龄了，早过了天赋的积累和开发期，如果还想依靠本能就可以做到专注，几乎是不可能的。</p><p><strong>你拥有多强烈的动机，你才能在多大程度上掌控自己的注意力</strong>。</p><p>心理学甚至研究发现，如果人们的动机足够强烈，即使连续三个晚上或更长时间不睡觉，也可以保持敏锐的专注力，但假如他们根本无所谓，那么很快就会开始打磕睡。</p><p>当我们通过“自上而下”系统有意识地去锻炼专注力的时候，这种能力最终会影响“自下而上”系统。</p><p>也就是说，专注其实是可以通过后天训练达到或加强的。</p><p>这些年，我把自己关于如何通过主动意识增强专注能力的方法总结成了三重境界。</p><p><strong>第一重境界：打造有利于专注的环境</strong>。</p><p>我一个朋友在腾讯做游戏，那是腾讯最庞大的部门，他们这群天资聪颖、每天晚上加班到12小时的人，主要工作就是为了让游戏更好玩，让你的注意力更集中到游戏之上。</p><p>另外一个在今日头条的朋友，做信息流，压力非常大，他以前在广告公司，做的广告超过10秒钟不能吸引到人，人们就会换台。但现在做信息流，如果一个页面5秒钟不能让人看进去，人们可能就会去点开别的A，所以他们需要不断研究出最能吸引人注意力的算法、制造更多噱头十足的内容。</p><p>结果他最近告诉我，他居然沉迷进了抖音，有时候就是不小心顺着链接点进去，不感兴趣就立马刷下一个，一不小心一两个小时就过去了。</p><p>从商业上看，腾讯、头条乃至抖音，它们都是成功的。</p><p>但对我而言，则是敲响巨大的警钟。</p><p>生活中的每一分每一秒都被这样的东西所占据，怎么可能集中注意力来做别的东西。</p><p>过量的信息消费的是人们的专注力，信息越多，人们越不专注，我们越是分心，就越难去深入地思考，思考时间越短，就越容易流于肤浅。</p><p>所以，对于像我这种天生专注力不强的人而言，最好的方法就是不要给自己的脆弱的专注力制造“敌人”，不看、不关注、不安装这些炫人耳目的东西，让自己处在一种更有利于专注的环境中。空出的时间，多去看纸质书籍，做深入思考。</p><p>这一重境界之所以最低，是因为完全依赖于和外界对抗，太被动。</p><p><strong>第二重境界：训练进入专注的模式</strong></p><p>集中注意力和收缩肌肉一样会产生疲劳。这意味着如果天生注意力不强，就不要去做什么看5个小时电影或者玩6个小时游戏后再学习工作的挑战了。</p><p>要学会用80%的精力去做20%的重要工作，更要学会通过有意识地锻炼，做到当需要专注的时候能很快收心，只要想投入注意力，就能投入。</p><p>比如有意识地把自己专注能力特别强的时候和某些声音、气味进行关联，当你需要专注的时候，就播放这种音乐、燃起某种香，提醒自己要进入专注模式了。</p><p>还比如，在需要专注的时候，用5分钟进行一下冥想，去平复大脑里纷繁复杂的思维，一旦察觉到自己走神，就提醒自己拉回来，如果再次走神，重复相同步骤，循环往复。经过练习之后，停止胡思乱想、保持专一思想会变得越来越简单。长期冥想者的大脑神经联结增多，与有实力的举重运动员拥有完美的胸肌是一样的道理。</p><p>还有一种极端方式，就是定期将自己置于某种“危险境地”，这就是很多人热爱登山等危险运动的原因之一，危险运动让本能接手对你大脑的控制，让你不得不投人全部专注力。通过这种方式去感受专注力的产生过程，去体会专注力强大的能量，有助于训练自己在日常生活中进入这种模式。</p><p>（时间管理的番茄工作法也是一种不错的训练方法，大脑会逐渐习惯这个时间周期，当你需要专注的时候，大脑会将专注力集中起来，感兴趣的可以微信后台回复“时间”查看相关文章。）</p><p>到了这一重，专注更依赖于自己内心的训练和法则，已经可以有意识地控制注意力了。</p><p><strong>第三重境界： 努力激发专注的心流</strong></p><p>当我们用意志力支撑专注力、有意识地抑制各种干扰，通过长期训练后，专注力就可能从主动行动变为被动形态，本能的专注力就能得到恢复和提升。</p><p>甚至有可能因为太过于专注，而进入到一种物我两忘、无喜无悲的状态，甚至连时间的流逝都感知不到。</p><p><strong>这种强烈的专注力所引发的平和、喜悦的感觉，叫做心流。</strong></p><p>可惜的是，绝大多数人只有在玩游戏时候才能有这种体验。</p><p>当然，心理学上还不带任何倾向地推荐了另外一种所有人都可以轻易就体验到心流的事情——做爱。</p><p>但除此外，所有那种需要通过主动意识去确保全身心投入的事情，比如看书、学习、工作、写代码之类的，大部分人都无法进入心流，大脑无时无刻不在提醒自己：累了累了，休息一会儿。</p><p>在生活中产生更多心流的一个秘诀是把我们的注意力和兴趣结合起来，能做到这一点的人无疑是幸运的，无论在哪个领域，凡是取得巨大成就的人都找到了这个结合点。</p><p>另外还有一些产生心流的途径，比如我们在全身心处理一件事的时候，把能力发挥到了极致，达到了“力所能及”的范围，心流也可能出现。</p><p>把大脑当成是一支军队，心流就是整支军队战斗力最强的时候，每一个单位都动员起来，冲锋的冲锋、射箭的射箭、运粮的运粮，数以亿计的神经信号川流不息而又井井有条。</p><p>那一刻，不同大脑区域之间的神经联结既频繁又精，在这种状态下，不管我们做什么都能发挥出最佳水平。</p><p>一些著名作家年轻时经常徜徉其间，文思泉涌，倚马千言，但随着精力衰退，无法进入这种状态后，甚至会尝试服用兴奋类药物。</p><p>侦探小说里的福尔摩斯也好、柯南也好，之所以看似随便走过一个地方，就能关注到常人所无法理解的惊人细节，也是因为他们能够长期保持心流的状态。</p><p>只可惜，对常人而言，心流永远都是一种可遇而不可求的理想状态，我自己偶尔才能在工作或写作中进入，所以无法准确描述那种美妙的感觉。</p><p>总结一下。绝大部分人的努力，都是在低效的勤奋中努力，要想突破天赋的束缚，需要在训练专注力上下更大的努力，因为只有这样子的努力，才可能弥补天赋上的不足。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM入门</title>
      <link href="/2020/02/09/ACM%E5%85%A5%E9%97%A8/"/>
      <url>/2020/02/09/ACM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>作者：数学lover<br>链接：<a href="https://www.zhihu.com/question/51727516/answer/127265733" target="_blank" rel="noopener">https://www.zhihu.com/question/51727516/answer/127265733</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>一般的入门顺序：</p><ol start="0"><li><p>C语言的基本语法(或者直接开C++也行，当一个java选手可能会更受欢迎，并且以后工作好找，但是难度有点大)，【参考书籍：刘汝佳的《算法竞赛入门经典》，C++入门可以考虑《c++ primer plus》，java选手可以考虑《think in java》or中文版《java编程思想》，请远离谭浩强…】<br>可以选择切一些特别水的题巩固以及适应一下ACM中常见的输入输出格式…例如杭电著名的100题 <a href="https://link.zhihu.com/?target=http%3A//acm.hdu.edu.cn/listproblem.php%3Fvol%3D11">Problem Set</a></p><a id="more"></a></li><li><p>一些基本算法和数据结构(队列 栈 树 图 并查集 堆 DFS BFS 最短路 最小生成树 拓扑排序 动态规划 贪心 搜索 KMP 哈希 Trie AC自动机 快速幂 逆元 费马小定理 欧拉函数 素数筛 分解质因数)你可以找两个小伙伴一起分工合作，各自认领专题【参考书籍：刘汝佳《算法竞赛入门经典第二版》or《算法竞赛训练手册》，《算法导论》】这时候可以刷的题就多了，你可以选择一些专题进行突破，学习一下技巧 例如<br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/65959%23overview">[kuangbin带你飞]专题一 简单搜索</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66569%23overview">[kuangbin带你飞]专题四 最短路练习</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66964%23overview">[kuangbin带你飞]专题五 并查集</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66965%23overview">[kuangbin带你飞]专题六 最小生成树 </a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/68966%23overview">[kuangbin带你飞]专题十二 基础DP1</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70017%23overview">[kuangbin带你飞]专题十四 数论基础</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70325%23overview">[kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70326%23overview">[kuangbin带你飞]专题十七 AC自动机</a><br>如果这些你和你的小伙伴都能熟悉掌握，并且能够尽快写出来，那么没有意外的话就可以在网络赛中拿到现场赛的门票（当然还得看出题人的风格…）</p><ol start="2"><li>一些进阶的算法以及复杂一些的数据结构（树状数组 线段树 平衡树 后缀数组 二分图匹配 网络流 费用流 割点 桥 强联通 双联通 最近公共祖先 四大DP(数位dp 区间dp 状压dp 概率dp)  博弈论SG函数 ）<br>【参考资料：各种博客……】<br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66989%23overview">[kuangbin带你飞]专题七 线段树</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/67418%23overview">[kuangbin带你飞]专题九 连通图</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/68127%23overview">[kuangbin带你飞]专题十 匹配问题</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/68128%23overview">[kuangbin带你飞]专题十一 网络流</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70324%23overview">[kuangbin带你飞]专题十五 数位DP</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70655%23overview">[kuangbin带你飞]专题十八 后缀数组</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/76505%23overview">[kuangbin带你飞]专题二十一 概率&amp;期望</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/77874%23overview">[kuangbin带你飞]专题二十二 区间DP</a><br>这些掌握之后在现场赛中拿到牌子应该就没什么问题了，发挥出色还能拿到银牌。。。不过如果遇到比较凶残的赛区…<br>2.5 这时候如果开始组队了，就可以去刷一些套题了，例如<a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest%23contestType%3D1%26contestRunningStatus%3D3%26contestOpenness%3D0%26title%3D%26manager%3D">Contests - Virtual Judge </a><br>这里每一场比赛都是过去真实发生的录像，你可以clone之后和自己的队友一起实操一下。</li></ol></li><li><p>更高深的技巧，更复杂的数据结构（树链剖分，动态树，可持久化线段树，DLX，后缀自动机，回文树，斜率优化/单调队列优化/四边形优化DP，插头dp，莫比乌斯反演……）<br>这部分最能体现人与人的差异了…智商碾压一般就在这部分。而要想拿到金牌，一般来说这些知识都要尽可能掌握。<br>【参考资料：各种论文，解题报告】<br>这部分的题目比较杂，因此请自行去vjudge上查找….</p></li><li><p>5 同2.5，并且中国国内的比赛如果已经满足不了你，你可以去<a href="https://link.zhihu.com/?target=https%3A//icpcarchive.ecs.baylor.edu/index.php">https://icpcarchive.ecs.baylor.edu/index.php</a> 或者<a href="https://link.zhihu.com/?target=http%3A//codeforces.com/gyms">Gym - Codeforces</a>上找到全世界的区域赛的题目，不过题解就不怎么保证了…</p></li></ol><p>也许你会觉得性价比很低，学这么多东西，才”有可能”拿到牌子，但是收获的不一定是物质的牌子，还有学习过程的苦辣酸甜的经历（例如各种WA TLE RE MLE 之后的一次AC），还有和基友一起并肩作战切套题的同甘共苦，而且还锻炼了自己的学习能力（善用百度，谷歌，维基百科）。<br>所以<br>Good Luck and Have Fun.<br>===============我是WA和AC之间的分割线===============<br>这些算法都是说着容易，但是灵活搭配用起来难，然后还能在一定时间内写出来，并顺利通过数据测试拿到AC更难。<br>由于大家手上的模板越来越强大，区域赛一般都不会出现裸的模板题了，一旦出现，肯定就是被大家骂回家的存在。所以在综合训练的过程中，尽量选择需要动脑的题目，不要一昧追求直接贴一个模板上来AC走人特别爽的题目。<br>一般比较需要动脑的题目类型：贪心，动态规划（最好需要加上优化的），组合数学（推组合数公式，各种等价变换），图论（网络流，最短路，匹配）的各种建图过程。。。<br>虽然说年轻人要少水群，多做题，才能进Finals——kuangbin<br>但是一直闭门单刷也不是一件好事，还是要和大家多多交流心得，这样才能避免自己陷入一个瓶颈。</p><p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/51727516/answer/127318167" target="_blank" rel="noopener">https://www.zhihu.com/question/51727516/answer/127318167</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>本人背景：大学之前没有搞过竞赛，天赋一般，今年大三出去比赛，今年（2016）区域赛铜。<br>经过一段时间的反思，结合自己这两年ACM训练就“请问ACM的正确入门方式是什么？” 发表一点拙见</p><p>目录</p><ol start="0"><li>预备知识</li><li>基础部分</li><li>进阶</li><li>做题</li><li>训练</li><li>杂谈</li></ol><p>注：本人对于掌握内容的等级由高到低分为：精通、掌握、了解</p><p><strong>0 预备知识</strong><br><strong>0.1 C++基础语法部分</strong><br>想要入门ACM，首先你要有一定的编程基础，一般国内的ACM选手都是用C++的，所以C++的基本语法你应该有所了解。</p><h6 id="0-1-1-库函数的了解"><a href="#0-1-1-库函数的了解" class="headerlink" title="0.1.1 库函数的了解"></a>0.1.1 库函数的了解</h6><p>包括但不限于这些库（头文件）：基本输入输出 如cstdio, iostream，以及一些从C的库弄过来的像cstring, cctype,cmath等库，具体可以随便百度一个人的代码，然后看看他的头文件</p><h6 id="0-1-2-基础知识"><a href="#0-1-2-基础知识" class="headerlink" title="0.1.2 基础知识"></a>0.1.2 基础知识</h6><p>如int的最大值是多少？int占多少内存？逻辑运算，循环等，不一一赘述。值得一提的是位运算，应当了解电脑中数据的存储方式，很多时候利用位运算帮助做题非常重要，如树状数组的lowbit，状压DP，快速幂等，每次我看到这些的时候都深深的感受到二进制的神奇。</p><p><strong>0.2 C++ STL</strong><br>非常有用的STL 如algorithm, vector, list, set, stack, queue, map等，对于STL的学习，本人推荐曾棕根老师的这本书《ACM程序设计》 <a href="https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1bpxa6qb">下载链接</a>，建议初学者了解每一个容器都有什么样的方法以及各个方法的<strong>时间复杂度</strong>。不同的容器利用了不同的数据结构，所以做出相应的操作对于系统的时间开销就大不相同，这点还是挺重要的。原来做一道题，网上看有人用vector TLE了，ctrl+f把所有的vector换成list就过了。</p><p><strong>0.3 Java基础</strong><br>个人感觉Java并不常用，当然Java中的<strong>BigInteger类（高精度整数）</strong>是非常有用的，一般情况下，当别人苦逼的粘贴C++的大数类研究方法的时候，Java可以十行代码优雅的解决问题，同时建议稍微学习一下BigDecimal类。</p><p><strong>0.4 时间复杂度和空间复杂度的计算</strong><br>时间复杂度是一个非常重要的概念，相同的问题，有的人给出的方法需要1s，有的人给出的方法需要1h，那必然是1s的方案在时间方面更优。<br>空间复杂度同理，如果空间很大，用不完，可以考虑<strong>使用空间换取时间</strong>的方式，很多算法都是以这个为前提的。<br>研究一下为什么很多题给的数据是10^5？一般题给出时间是1s，有的给出2s, 3s 甚至15s，是否能给你想法上的暗示？空间复杂度同理。</p><p><strong>0.5 ACM中的基本错误</strong><br>Wrong Answer： 有自己没有注意到的细节，或者方法错了。<br>TLE： 运行时间超过给出时间<br>CE：编译错误，可以点进去看<br>RE：有时候会stack overflow，access violation之类的<br>PE：空格或者回车有问题</p><p><strong>1 基础知识</strong><br>大一的时候一开始就学了二分/三分，BFS、DFS去找迷宫路径，当时只能循规蹈矩的改模版，当时并不懂栈（stack）和队列（queue），每次都要纠结一下是FIFO还是FILO。后来做着做着题，发现，像BFS、DFS这种东西，完全就是个思想啊，哪里有什么模版。此时，我大概可以随手写一些深搜、广搜了，但是我对于这些的应用还是不太敏感，只有多做题才能一直提醒自己灵活的运用这些。</p><p>所以，上面这段话，我想表达这样一个事情：基础要学好，达到<strong>精通</strong>的程度，并且要多做题，每一种要做20道题左右。（本人训练的时候大概是10题的样子，但是感觉并不够，所以建议20道）</p><p>基础的内容：<br>BFS、DFS、二分、三分、筛法求素数、快速幂、并查集、矩阵运算及快速幂、最短路相关（Dijkstra， floyd，ford，</p><p>SPFA</p><p>）、基础DP（LIS、LCS、记忆化搜索等）、网络流（EK、Dinic、ISAP+gap）、KMP、线段树、树状数组、二分图、最小生成树（Prim、Kruskal）、计算几何基础等</p><p>按照紫书上的来吧，题主看紫书觉得很吃力，其实说实话，我本人看紫书也挺吃力的，建议先从Vjudge上找相关专题做，比如高票答案推荐的kuangbin带你飞系列的，HDU的题个人感觉比UVA要简单一些。</p><p><strong>2. 进阶</strong><br>这个阶段其实就可以和队友分工搞了，推荐<strong>参考白书以及多校训练</strong>。</p><p>我个人对这个阶段的建议是：<strong>一部分内容学会用板子，大概知道板子每一步在干什么，达到了解的程度。一部分内容要掌握原理。</strong>如果实在不知道在干什么，就当用黑箱一样去用。就像你知道cmath里有sqrt，但是很多人完全不知道是怎么实现的。</p><p>像很多数论的东西，比如Lucas，你会用模版大概就可以了，这种东西几乎没有什么改的必要，但是了解一下什么时候用lucas求组合数，什么时候打表求组合数之类的还是很有必要的，对于不同情形应使用不同的方法。</p><p>但是对于像莫比乌斯反演、sg函数这种东西，经常就需要对于具体情况分析，然后将思想运用到代码中。</p><p>还有一些比较中立的，比如Tarjan求联通分量的，改的虽然不多，直接用板子，但是可以存储很多信息，如无向图割点、桥，以及对于强联通分量、双联通分量能发挥不同的功能。只能靠做题量去学习姿势。</p><p><strong>3. 做题</strong><br>ACM我一直觉得非常靠天赋，对于自己这样天赋一般的人，某些选手简直是智商碾压般的存在。后来发现也不尽然，人家天赋高，做一道题付出的时间相对于自己短，相同的时间可以做更多的题，所以强者更强，弱的还是原来的水平。所以，不管你的天赋强弱，多做题吧，付出和收获都是成正比的，天赋的高低的区别只在于将你的收获乘以0.8还是乘以1.2。比如一个天赋很强的人，做了400道题，那么相当于一个普通人做了400 * 1.2 = 480题的水平，对于天赋差一点的人来讲，就要做480 / 0.8 = 600题。大部分人的智商都是差不多的，真正强的人都是做题做出来的，我个人不太相信有谁看一眼C++的语法就能想出来个主席树、莫队算法的，当达到量的高度以后自然会有质的飞跃。BestCoder上的<a href="https://link.zhihu.com/?target=http%3A//bestcoder.hdu.edu.cn/rating.php%3Fuser%3Ddoubility">Rating - doubility</a>，我一天无意间看到了人家在Vjudge上的做题量1748，<a href="https://link.zhihu.com/?target=http%3A//vjudge.net/user/doubility">doubility’s profile</a>。Q神，BNU做题量1715，<a href="https://link.zhihu.com/?target=https%3A//www.bnuoj.com/v3/userinfo.php%3Fname%3Dquailty">Information of quailty</a>。以上两人还仅限于一个平台，并不知道其他平台还有多少题。就我个人而言，只做了570题的水平，其中还包括很多水题。听学长说叉姐的做题量大概是五位数，甚至六位数，所以也并不奇怪人家那么强。在普通人智商差不多的情况下，比赛时金银铜大概都是按做题量分配的，这种大家都喝了无数碗的鸡汤，咱们再干一碗。</p><p>回到正题，打开ACM的正确方式：<br><strong>刷题，BestCoder开了有几十场了，CodeForces有几百场，你做了多少了？</strong></p><p><strong>4. 训练</strong><br>个人的意志力太薄弱，如果有机会的话还是组队训练吧。有组织的训练至少有竞争，有压力。赛后尽可能的AK比赛的题，当时我平时训练的时候没有ak，现在回想起来，陷入了不会，下次遇到还不会，再遇到还不会的循环。</p><p>组队的话尽可能强强联手吧，大家合作拿一个大奖才是最好的结果。当队友心猿意马的时候确实挺让人泄气的，举个杭电某队的例子。</p><blockquote><p>G题因为题意问题，加上我太蠢没有学会潜在坑点分析+脑补。<br>加上B题我没有担当起责任，没有解放队友，导致最终打了个铜。</p><p>主要原因还是自己太弱。<br>争取在上海的时候拿个金，至少正常水平发挥拿到ECfinal参赛权。<br>队友一个进过WF没了干劲，另外一个想要找工作，也没了热情。虽然他们水平很厉害，但希望在明年，能够不再和”马上打比赛的时候嘴里却喊着退役，什么结果都无所谓的人”组队，消极的队友，会带给你一种无力感，真的很累很累。其实还不如单挑，虽然名次会变低，但是至少充满斗志和热情。</p><p>转自 <a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/snowy_smile/article/details/49450163">2015沈阳赛区总结 与 简单题题解</a></p></blockquote><p><strong>5. 杂谈</strong><br>\1. 善用搜索引擎吧，有时候Google和百度搜出来的题解不一样，虽然我也不知道他们是怎么排名的。看别人的代码总会发现新姿势。在这里推荐一个利益无关的搜索引擎：<a href="https://link.zhihu.com/?target=http%3A//byr.wiki">Byr.wiki·北邮人导航</a><br>\2. 写写题解，整理个自己的模版，其实别人能搜到自己的题解和模版，感觉还是挺开心的<br>\3. 别自欺欺人的拿天赋说事了，以绝大部分人努力程度之低，完全到不了拼天赋的地步。沉下心，踏踏实实的学，把紫书白书好好看，做足够量的BC/CF题。<br>\4. 只有自己足够强，才能和足够强的人组队，才能比赛拿牌<br>\5. 高票答案谈到性价比，其实我自己也不知道ACM的性价比怎么样，但是大学里，有个事做总是好的吧？<br>\6. 原来在网上看到过一篇<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/sjf0115/article/details/8664562">ACM进阶之路</a>，供大家参考</p><p>每次查题解的时候总可以看到两句话，无耻的摘录了<br>\1. “每一次AC都是一次感动” 这个似乎是一个CSDN博主的名字<br>\2. “人一我百！人十我万！永不放弃<del>~</del>怀着自信的心，去追逐梦想。” –kuangbin</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
